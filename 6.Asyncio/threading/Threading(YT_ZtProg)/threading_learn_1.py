import time
import threading


def get_data(data):
    while True:
        name_curr_thr = threading.current_thread().name  # имя текущего потока
        print(f"[{name_curr_thr}] - {data}")
        time.sleep(1)


# get_data без () говорит, нам о том что мы передаем адрес, а не результат исполнения
thr = threading.Thread(target=get_data, args=(str(time.time()),), name="thr_1")
# thr.name  # возвращает имя потока
# thr.daemon  # является ли поток демоном?
# thr.is_alive()  # работает ли нащ поток в текущее время
thr.start()

for i in range(100):
    print(f"current: {i}")
    time.sleep(1)
    # когда будет 10ая итерация проверим работает ли наш поток до сих пор
    # также проверим выведим список всех активных потоков
    # также количество всех запущенных потоков
    if i % 10 == 0:
        print("active thread: ", threading.active_count())  # число активных потоков (должно быть 2, основной и который создали, если больше
        # то это какие то вспомогательные потоки PyCharm
        print("enumarate: ", threading.enumerate())  # вывод всех потоков которые запущены на данный момент
        # enumarate:  [<_MainThread(MainThread, started 21448)>, <Thread(thr_1, started 18224)>]
        # где MainThread - основной поток, это что последовательно и без создания нашего потоква выполняет
        # а второй, это уже наш созданный поток под именем thr-1
        print("thr-1 is alive: ", thr.is_alive())  # также проверяем поток который запустили выше цикла
thr.join()  # дождаться исполнения потока и только после исполнения потока выполнить
# последующий код, без join при последовательном исполнении кода, как бы мы прочли то что запустили потоки
# но не ждем пока оно не вернет результат, а сразу переходим к следующей строчке кода, а с join дожидаемся и
# и только потом начинаем выполнять следующую строчку кода