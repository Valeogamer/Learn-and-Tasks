# Проблема в том, что обычным присваиванием значения переменным,
# которые ссылаются на экземпляры классов, здесь не обойтись.
# Ведь при присваивании значения переменным просто «перебрасываются» ссылки.
# Так, если некоторая переменная х ссылается на экземпляр класса,
# то после выполнения команды у=х переменная у будет ссылаться на тот самый экземпляр,
# что и переменная х. И это не то, что нам нужно. Нам нужно, образно выражаясь,
# чтобы переменная у ссылалась на экземпляр с точно такими же характеристиками,
# как у экземпляра, на который ссылается переменная х.

# В принципе для создания копии экземпляра можно воспользоваться функциями сору() или deepcopy()
# из модуля сору. При использовании функции сору() создается поверхностная копия экземпляра,
# в то время как функция deepcopy() позволяет создавать полные копии.
# Разница между поверхностной и полной копиями проявляется,
# когда среди полей экземпляров имеются переменные, ссылающиеся на данные изменяемых типов
# (примером могут быть списки). Небольшая иллюстрация к использованию этих функций приведена ниже:

from copy import copy, deepcopy


class MyClass:
    def __init__(self, name: str, nums: list[int]):
        self.__name = name
        self.__nums = nums

    def __repr__(self):
        return f'Мой класс'

    @property
    def name(self):
        return

    @name.getter
    def name(self):
        return self.__name

    @name.setter
    def name(self, new_name: str):
        self.__name = new_name

    @property
    def nums(self):
        return

    @nums.getter
    def nums(self):
        return self.__nums

    @nums.setter
    def nums(self, new_nums: list[int]):
        self.__nums = new_nums

    def show(self):
        print(f'name: {self.__name}\nnums: {self.__nums}')


if __name__ == '__main__':
    my_class_1 = MyClass('first', [1, 1, 1])
    my_class_1.show()
    # Делаем поверхностную копию
    low_copy = copy(my_class_1)  # будет ссылаться на экземпляр, и при изменении изменяемых типов
    # экземпляра, копия тоже будет менять значения, так как просто висят ссылки ярлыки на экземпляр(ориг)
    # Полная копия
    high_copy = deepcopy(my_class_1)  # при полной копии уже не ссылки, а как будто отдельный экземпляру
    print('Поверхностная копия экземпляра my_class_1: ')
    low_copy.show()
    print('Полная копия экземпляра my_class_1: ')
    high_copy.show()
    # изменим значения поля name у low_copy
    my_class_1.name = 'Second'  # так как str не изменяемый то изменит только у данного экземпляра у других не изменится
    my_class_1.nums[0] = 5  # Так как список изменяемый то у копи тоже изменятся значения

    # На следующем этапе командами х.name = «Second» и х.nums[0] = 5
    # изменяется значение поля name экземпляра х и первый (с нулевым индексом) элемент в списке nums,
    # являющемся полем этого же экземпляра. Командам х.show() , у.s how() и z.show() проверяем,
    # изменились ли (и если да, то как) поля экземпляров х, у и z. С экземпляром х все просто.
    # Его поля изменились строго в соответствии с теми командами,
    # которые были выполнены при присваивании значений.

    # Поля экземпляра z (полная копия) не изменились. Что касается экземпляра у,
    # то у него не изменилось поле name, но изменилось поле-список nums (первый элемент стал нулевым,
    # как и у экземпляра х). Объяснение в том, что при создании поверхностной копии для изменяемых типов,
    # таких как списки, выполняется копирование ссылок, но не значений.
    # Поэтому реально экземпляры х и у (поверхностная копия х) ссылаются через свои поля nums на один и тот же список,
    # тогда как у экземпляра z (полная копия х) поле nums «персональное».

    # Сделаем отображение полей
    print('--my_class_1--')
    my_class_1.show()
    print('--low_copy--')
    low_copy.show()
    print('--high_copy--')
    high_copy.show()
    # Адресс экземпляра
    print(id(my_class_1))
    print(id(low_copy))
    print(id(high_copy))
